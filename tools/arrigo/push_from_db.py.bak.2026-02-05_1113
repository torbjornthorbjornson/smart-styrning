#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
push_from_db.py
- HÃ¤mtar elpriser (ENDAST 96 perioder)
- RÃ¤knar rank och trÃ¶sklar
- Bygger 32-bitarsmasker (EC/EX)
- Pushar PRICE_RANK, PRICE_VAL, masker, OAT och PRICE_OK
"""

import os, re, base64
from datetime import datetime, date, time, timedelta
from zoneinfo import ZoneInfo
import pymysql, requests
from configparser import ConfigParser

TZ  = ZoneInfo("Europe/Stockholm")
UTC = ZoneInfo("UTC")
LOG_PATH = "/home/runerova/smartweb/tools/arrigo/logs/arrigo_push.log"

# === PERIODER: HEAT KRÃ„VER 96, PUNKT ===
PERIODS = int(os.getenv("ARRIGO_PERIODS", "96"))
if PERIODS != 96:
    raise SystemExit(f"FATAL: ARRIGO_PERIODS={PERIODS} â€“ HEAT krÃ¤ver 96 perioder")

# ---- HjÃ¤lp ----
def log(msg):
    now = datetime.now(TZ).strftime("%Y-%m-%d %H:%M:%S")
    try:
        with open(LOG_PATH, "a", encoding="utf-8") as f:
            f.write(f"{now} {msg}\n")
    except Exception:
        pass
    print(msg, flush=True)

def read_db_config():
    cfg = ConfigParser()
    cfg.read("/home/runerova/.my.cnf")
    return {
        "host": "localhost",
        "user": cfg["client"]["user"],
        "password": cfg["client"]["password"],
        "database": "smart_styrning",
        "charset": "utf8mb4",
        "cursorclass": pymysql.cursors.DictCursor,
    }

def getenv_any(names, required=False, default=None):
    for n in names:
        v = os.environ.get(n)
        if v is not None:
            return v
    if required:
        raise KeyError(f"Saknar nÃ¥gon av: {', '.join(names)}")
    return default

def ensure_b64(s: str) -> str:
    s = s.strip()
    try:
        base64.b64decode(s)
        return s
    except Exception:
        return base64.b64encode(s.encode("utf-8")).decode("ascii")

def build_verify():
    if os.getenv("ARRIGO_INSECURE", "0") == "1":
        return False
    return os.getenv("REQUESTS_CA_BUNDLE") or True

def arrigo_login(login_url, user, password, verify):
    r = requests.post(
        login_url,
        json={"username": user, "password": password},
        timeout=15,
        verify=verify
    )
    r.raise_for_status()
    tok = r.json().get("authToken")
    if not tok:
        raise SystemExit("Inget authToken i login-svar")
    return tok

def gql(url, token, query, variables, verify):
    r = requests.post(
        url,
        headers={"Authorization": f"Bearer {token}"},
        json={"query": query, "variables": variables},
        timeout=30,
        verify=verify
    )
    r.raise_for_status()
    j = r.json()
    if "errors" in j:
        raise SystemExit("GraphQL-fel: " + str(j["errors"]))
    return j["data"]

# ---- Pris frÃ¥n DB ----
def fetch_prices(which: str):
    today_local = datetime.now(UTC).astimezone(TZ).date()
    day_local = today_local + timedelta(days=1) if which == "tomorrow" else today_local

    start_local = datetime.combine(day_local, time(0, 0), tzinfo=TZ)
    end_local   = start_local + timedelta(days=1)

    start_utc = start_local.astimezone(UTC).replace(tzinfo=None)
    end_utc   = end_local.astimezone(UTC).replace(tzinfo=None)

    log(f"ðŸ“… HÃ¤mtar priser fÃ¶r {which} ({day_local}) â†’ UTC[{start_utc} â†’ {end_utc}]")

    conn = pymysql.connect(**read_db_config())
    with conn, conn.cursor() as cur:
        cur.execute("""
            SELECT datetime, price
            FROM electricity_prices
            WHERE datetime >= %s AND datetime < %s
            ORDER BY datetime
        """, (start_utc, end_utc))
        rows = cur.fetchall()

    if len(rows) != PERIODS:
        log(f"âš ï¸ Antal perioder i DB: {len(rows)} (fÃ¶rvÃ¤ntat {PERIODS})")

    return rows, day_local

def normalize_periods(rows):
    per_slot = {i: [] for i in range(PERIODS)}

    for r in rows:
        dt = r["datetime"].replace(tzinfo=UTC).astimezone(TZ)
        idx = dt.hour * 4 + (dt.minute // 15)
        if 0 <= idx < PERIODS:
            per_slot[idx].append(float(r["price"]))

    out = []
    for i in range(PERIODS):
        price = sum(per_slot[i]) / len(per_slot[i]) if per_slot[i] else 0.0
        out.append((i, price))

    return out

def pack_masks(slots, periods=PERIODS):
    nwords = (periods + 31) // 32
    words = [0] * nwords
    for s in slots:
        words[s // 32] |= (1 << (s % 32))
    return words

def build_rank_and_masks(rows):
    slot_price = normalize_periods(rows)
    prices = [p for _, p in slot_price]

    sorted_prices = sorted(prices)
    mid = PERIODS // 2
    median = (sorted_prices[mid - 1] + sorted_prices[mid]) / 2.0

    cheap_pct = float(getenv_any(["ARRIGO_CHEAP_PCT"], default="-0.50"))
    exp_pct   = float(getenv_any(["ARRIGO_EXP_PCT"], default="+1.50"))

    cheap_thr = median * (1.0 + cheap_pct)
    exp_thr   = median * (1.0 + exp_pct)

    cheap_slots = [i for i, p in slot_price if p <= cheap_thr]
    exp_slots   = [i for i, p in slot_price if p >= exp_thr]

    ec_masks = pack_masks(cheap_slots)
    ex_masks = pack_masks(exp_slots)

    sorted_idx = sorted(range(PERIODS), key=lambda i: slot_price[i][1])
    idx_to_rank = {i: r for r, i in enumerate(sorted_idx)}
    rank = [idx_to_rank[i] for i, _ in slot_price]

    log(f"ðŸ“Š Median={median:.3f}, cheap_thr={cheap_thr:.3f}, exp_thr={exp_thr:.3f}")
    return rank, ec_masks, ex_masks, slot_price

# ---- OAT ----
def daily_avg_oat(day_local: date):
    start_local = datetime.combine(day_local, time(0, 0), tzinfo=TZ)
    end_local   = start_local + timedelta(days=1)

    start_utc = start_local.astimezone(UTC).replace(tzinfo=None)
    end_utc   = end_local.astimezone(UTC).replace(tzinfo=None)

    conn = pymysql.connect(**read_db_config())
    with conn, conn.cursor() as cur:
        cur.execute(
            "SELECT AVG(temperature) AS avgtemp FROM weather WHERE timestamp >= %s AND timestamp < %s",
            (start_utc, end_utc)
        )
        row = cur.fetchone()

    return round(float(row["avgtemp"]), 1) if row and row["avgtemp"] is not None else None

# ---- Push ----
def push_to_arrigo(rank, ec_masks, ex_masks, day_local, oat_yday, oat_tmr, slot_price):
    login_url   = getenv_any(["ARRIGO_LOGIN_URL"], True)
    graphql_url = getenv_any(["ARRIGO_GRAPHQL_URL"], True)
    user        = getenv_any(["ARRIGO_USER", "ARRIGO_USERNAME"], True)
    password    = getenv_any(["ARRIGO_PASS", "ARRIGO_PASSWORD"], True)
    pvl_raw     = getenv_any(["ARRIGO_PVL_B64", "ARRIGO_PVL_PATH"], True)

    pvl_b64 = ensure_b64(pvl_raw)
    verify  = build_verify()

    token = arrigo_login(login_url, user, password, verify)

    data = gql(
        graphql_url,
        token,
        'query($path:String!){ data(path:$path){ variables{ technicalAddress } } }',
        {"path": pvl_b64},
        verify
    )

    vars_list = (data.get("data") or {}).get("variables") or []

    idx_rank, idx_vals = {}, {}
    idx_stamp = idx_price_ok = idx_oat_yday = idx_oat_tmr = None
    idx_ec32, idx_ex32 = {}, {}

    for i, v in enumerate(vars_list):
        ta = (v.get("technicalAddress") or "").strip()

        m = re.search(r"PRICE_RANK\((\d+)\)$", ta)
        if m:
            idx_rank[int(m.group(1))] = i
            continue

        m = re.search(r"PRICE_VAL\((\d+)\)$", ta)
        if m:
            idx_vals[int(m.group(1))] = i
            continue

        if ta.endswith(".PRICE_OK"): idx_price_ok = i; continue
        if ta.endswith(".PRICE_STAMP"): idx_stamp = i; continue
        if ta.endswith(".OAT_mean_yday"): idx_oat_yday = i; continue
        if ta.endswith(".OAT_mean_tomorrow"): idx_oat_tmr = i; continue

        m = re.search(r"EC_MASK32_(\d+)$", ta)
        if m:
            idx_ec32[int(m.group(1))] = i
            continue

        m = re.search(r"EX_MASK32_(\d+)$", ta)
        if m:
            idx_ex32[int(m.group(1))] = i
            continue

    log(f"ðŸ§­ PRICE_RANK map: {sorted(idx_rank.items())}")

    if idx_price_ok is not None:
        gql(graphql_url, token,
            "mutation($v:[VariableKeyValue!]!){writeData(variables:$v)}",
            {"v": [{"key": f"{pvl_b64}:{idx_price_ok}", "value": "0"}]},
            verify)
        log("ðŸ”’ PRICE_OK=0")

    writes = []

    for i in range(PERIODS):
        if i in idx_rank:
            writes.append({"key": f"{pvl_b64}:{idx_rank[i]}", "value": str(rank[i])})

    for i, price in slot_price:
        if i in idx_vals:
            writes.append({"key": f"{pvl_b64}:{idx_vals[i]}", "value": f"{price:.2f}"})

    if idx_stamp is not None:
        writes.append({"key": f"{pvl_b64}:{idx_stamp}", "value": day_local.strftime("%Y%m%d")})

    if idx_oat_yday is not None and oat_yday is not None:
        writes.append({"key": f"{pvl_b64}:{idx_oat_yday}", "value": str(oat_yday)})

    if idx_oat_tmr is not None and oat_tmr is not None:
        writes.append({"key": f"{pvl_b64}:{idx_oat_tmr}", "value": str(oat_tmr)})

    for i, val in enumerate(ec_masks, start=1):
        if i in idx_ec32:
            writes.append({"key": f"{pvl_b64}:{idx_ec32[i]}", "value": str(val)})

    for i, val in enumerate(ex_masks, start=1):
        if i in idx_ex32:
            writes.append({"key": f"{pvl_b64}:{idx_ex32[i]}", "value": str(val)})

    gql(graphql_url, token,
        "mutation($v:[VariableKeyValue!]!){writeData(variables:$v)}",
        {"v": writes},
        verify)

    log(f"âœ… Skrev {len(writes)} variabler")

    if idx_price_ok is not None:
        gql(graphql_url, token,
            "mutation($v:[VariableKeyValue!]!){writeData(variables:$v)}",
            {"v": [{"key": f"{pvl_b64}:{idx_price_ok}", "value": "1"}]},
            verify)
        log("ðŸ”“ PRICE_OK=1")

# ---- Main ----
def main():
    which = os.getenv("RANK_WHEN", "today")
    rows, day_local = fetch_prices(which)

    rank, ec_masks, ex_masks, slot_price = build_rank_and_masks(rows)

    today = date.today()
    oat_yday = daily_avg_oat(today - timedelta(days=1))
    oat_tmr  = daily_avg_oat(today + timedelta(days=1))

    push_to_arrigo(rank, ec_masks, ex_masks, day_local, oat_yday, oat_tmr, slot_price)

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        log(f"ðŸ’¥ Fel: {e}")
        raise
